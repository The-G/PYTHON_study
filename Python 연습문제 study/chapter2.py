# 문자열
# Q1.
pin = "881120-1068234"
yyyymmdd = pin[:6]
num = pin[7:]
print(yyyymmdd)
print(num)
#Q2.
pin = "881120-1068234"
print(pin[7])

#리스트
#Q1
a = [1, 3, 5, 4, 2]
print(a)
a.sort()
print(a)
a.reverse()
print(a)

#Q2.
a = ['Life','is','too','short']
result = a[0] + ' ' + a[1] + ' ' + a[2] + ' ' + a[3]
print(result)


#튜플
# Q1.
a = (1, 2, 3)
a = a + (4,)
print(a)


# 딕셔너리
#Q1.
a = {'A':90,'B':80,'C':70}
result = a['B']
del a['B']
print(a)
print(result)

# 집합
a = [1,1,1,2,2,3,3,3,4,4,5]
aSet = set(a)
b = list(aSet)
print(b)

# 변수
    # Q.파이썬은 다음처럼 동일한 값에 여러개의 변수를 선언할 수 있다.
    # 아래와 같이 a,b 변수를 선언 한 후 a의 첫 번째 요소값을
    # 변경하면 b의 값은 어떻게 될까? 그리고 이런 결과가 나오는 이유에
    # 대해서 설명해 보자.
a = b = [1,2,3]
a[1] = 4
print(b)
    # A. a의 변경이 b에도 적용이 되었다.. 꼭 a가 b와 연동되어 있는 것 처럼
    # 그 이유를 알기 위해서는 먼저 파이썬의 변수라는 것에 대한 개념이 필요하다.
    # a= [1,2,3]은 a는 변수의 이름이며, [1,2,3] 이라는 list 객체가 저장된 메모리 위치를 가리키게 된다.
    # 즉, 변수 a는 객체가 저장된 메모리의 위치를 가리키는 레퍼런스(Reference)라고도 할 수 있다.
    # 그래서 a = [1,2,3]이고 b = [1,2,3] 이면 a is b 는 True가 나온다. 이는
    # a와 b가 [1,2,3] 이라는 동일한 객체를 가리키고 있다는 뜻이다!!!!!
    # 이 a와 b가 정말 같은 객체를 가리키는 건지 확인해 보면,
    #    import sys
    #    sys.getrefcount([1,2,3])
    # 이 코드로 객체 [1,2,3]을 참조하고 있는 참조자 개수를 확인 할 수 있다.
    # 이후 c = [1,2,3], 하면 sys.getrefcount([1,2,3]) 가 1 증가한 것을 확인 할 수 있다.
    # 정리하자면, a, b 모두 같은 리스트인 [1,2,3]을 가리키고 있었기 때문에 a와 b가 같이 변하는 것이다.
    # 이를 방지하는 방법에는 b = a[:] 와 b = copy(a) 방법이 있다.

